import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import sgMail from "@sendgrid/mail";
import { EmailClient, KnownEmailSendStatus } from "@azure/communication-email";
import twilio from "twilio";
import { Retell } from "retell-sdk";

/**
 * TypeScript interface for the Retell AI call object
 */
interface RetellCallObject {
    call_id: string;
    agent_id: string;
    start_timestamp: number;
    end_timestamp: number;
    transcript: string;
    summary?: string;
    // Support both old format (analysis) and new format (call_analysis)
    analysis?: {
        incident_liability_insurance_status?: string;
        caller_name?: string;
        incident_is_customer_primary_contact?: string | boolean;
        current_customer?: string | boolean;
        cybersecurity_insurance_provider_name?: string;
        non_IR_inquiry_reason?: string;
        caller_email_address?: string;
        company_name?: string;
        caller_phone_number?: string | number;
        IR_call_description?: string;
        non_IR_call_description?: string;
        caller_location?: string;  // NEW: City, State format
        is_security_incident?: boolean;  // NEW: Boolean indicating if this is a security incident
    };
    call_analysis?: {
        call_summary?: string;
        user_sentiment?: string;  // NEW: Caller's sentiment (Positive/Negative/Neutral)
        call_successful?: boolean;  // NEW: Whether the call was completed successfully
        in_voicemail?: boolean;  // NEW: Whether the call went to voicemail
        custom_analysis_data?: {
            incident_liability_insurance_status?: string;
            caller_name?: string;
            incident_is_customer_primary_contact?: boolean | string;
            current_customer?: boolean | string;
            cybersecurity_insurance_provider_name?: string;
            non_IR_inquiry_reason?: string;
            caller_email_address?: string;
            company_name?: string;
            caller_phone_number?: number | string;
            IR_call_description?: string;
            non_IR_call_description?: string;
            caller_location?: string;  // NEW: City, State format
            is_security_incident?: boolean;  // NEW: Boolean indicating if this is a security incident
        };
    };
    metadata?: Record<string, any>;
    // Optional fields present in RetellAI call payloads
    recording_url?: string;
    recording_multi_channel_url?: string;
    // Transcript object is an array of speaker turns with role + content
    transcript_object?: Array<{ role: string; content: string; [key: string]: any }>;
    public_log_url?: string;
    // Call metadata
    duration_ms?: number;  // NEW: Call duration in milliseconds
    disconnection_reason?: string;  // NEW: How the call ended (user_hangup, agent_hangup, etc.)
    call_status?: string;  // NEW: Call status (ended, in_progress, etc.)
    call_type?: string;  // NEW: Type of call (phone_call, web_call, etc.)
    agent_name?: string;  // NEW: Name of the agent that handled the call
    // Call cost information (cost is in cents)
    call_cost?: {
        combined_cost?: number;
        total_duration_seconds?: number;
        total_duration_unit_price?: number;
        product_costs?: Array<{
            product: string;
            unit_price: number;
            cost: number;
        }>;
    };
}

/**
 * TypeScript interface for the Retell AI webhook payload
 * The webhook wraps the call object in an event envelope
 */
interface RetellWebhookPayload {
    event: 'call_started' | 'call_ended' | 'call_analyzed';
    call: RetellCallObject;
}

// For backward compatibility, keep the old interface name as an alias
type RetellAnalysisPayload = RetellCallObject;

/**
 * Configuration object for all external service credentials
 */
interface ServiceConfig {
    emailProvider: 'sendgrid' | 'azure';  // Email provider selection
    sendgrid: {
        apiKey: string;
        fromEmail: string;
        toEmail: string;
    };
    azureEmail: {
        connectionString: string;
        senderEmail: string;
        recipientEmail: string;
    };
    teams: {
        webhookUrl: string;
    };
    twilio: {
        accountSid: string;
        authToken: string;
        fromNumber: string;
        toNumber: string;
    };
    jira: {
        apiUrl: string;
        userEmail: string;
        apiToken: string;
        projectKey: string;
    };
    nonIrEmail: {
        recipientEmail: string;
    };
    featureFlags: {
        enableEmail: boolean;
        enableTeams: boolean;
        enableSms: boolean;
        enableJira: boolean;
    };
}

/**
 * Load and validate all required environment variables
 */
function loadConfiguration(): ServiceConfig {
    // Read feature flags (default to false for fail-safe behavior)
    const enableEmail = process.env.ENABLE_EMAIL_NOTIFICATIONS?.toLowerCase() === 'true';
    const enableTeams = process.env.ENABLE_TEAMS_NOTIFICATIONS?.toLowerCase() === 'true';
    const enableSms = process.env.ENABLE_SMS_NOTIFICATIONS?.toLowerCase() === 'true';
    const enableJira = process.env.ENABLE_JIRA_NOTIFICATIONS?.toLowerCase() === 'true';

    // Determine email provider (default to sendgrid for backward compatibility)
    const emailProvider = (process.env.EMAIL_PROVIDER?.toLowerCase() === 'azure' ? 'azure' : 'sendgrid') as 'sendgrid' | 'azure';

    // Build list of required environment variables based on enabled features
    const requiredEnvVars: string[] = [];

    if (enableEmail) {
        if (emailProvider === 'sendgrid') {
            requiredEnvVars.push('SENDGRID_API_KEY', 'SENDGRID_FROM_EMAIL', 'IRT_EMAIL_ADDRESS');
        } else if (emailProvider === 'azure') {
            requiredEnvVars.push('AZURE_COMMUNICATION_CONNECTION_STRING', 'AZURE_COMMUNICATION_SENDER_EMAIL', 'IRT_EMAIL_ADDRESS');
        }
    }

    if (enableTeams) {
        requiredEnvVars.push('TEAMS_WEBHOOK_URL');
    }

    if (enableSms) {
        requiredEnvVars.push('TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_FROM_NUMBER', 'ONCALL_PHONE_NUMBER');
    }

    if (enableJira) {
        requiredEnvVars.push('JIRA_API_URL', 'JIRA_USER_EMAIL', 'JIRA_API_TOKEN', 'JIRA_PROJECT_KEY');
    }

    // Non-IR email recipient is optional (defaults to IRT_EMAIL_ADDRESS if not set)
    // No validation needed since it's optional

    // Validate that required variables for enabled features are present
    const missing = requiredEnvVars.filter(varName => !process.env[varName]);
    if (missing.length > 0) {
        throw new Error(`Missing required environment variables for enabled features: ${missing.join(', ')}`);
    }

    return {
        emailProvider,
        sendgrid: {
            apiKey: process.env.SENDGRID_API_KEY || '',
            fromEmail: process.env.SENDGRID_FROM_EMAIL || '',
            toEmail: process.env.IRT_EMAIL_ADDRESS || ''
        },
        azureEmail: {
            connectionString: process.env.AZURE_COMMUNICATION_CONNECTION_STRING || '',
            senderEmail: process.env.AZURE_COMMUNICATION_SENDER_EMAIL || '',
            recipientEmail: process.env.IRT_EMAIL_ADDRESS || ''
        },
        teams: {
            webhookUrl: process.env.TEAMS_WEBHOOK_URL || ''
        },
        twilio: {
            accountSid: process.env.TWILIO_ACCOUNT_SID || '',
            authToken: process.env.TWILIO_AUTH_TOKEN || '',
            fromNumber: process.env.TWILIO_FROM_NUMBER || '',
            toNumber: process.env.ONCALL_PHONE_NUMBER || ''
        },
        jira: {
            apiUrl: process.env.JIRA_API_URL || '',
            userEmail: process.env.JIRA_USER_EMAIL || '',
            apiToken: process.env.JIRA_API_TOKEN || '',
            projectKey: process.env.JIRA_PROJECT_KEY || 'IRT'
        },
        nonIrEmail: {
            recipientEmail: process.env.NON_IR_EMAIL_RECIPIENT || process.env.IRT_EMAIL_ADDRESS || ''
        },
        featureFlags: {
            enableEmail,
            enableTeams,
            enableSms,
            enableJira
        }
    };
}

/**
 * Determine if a call is an IR (Incident Response) call
 */
function isIrCall(payload: RetellAnalysisPayload): boolean {
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};

    // A call is considered IR if it has an IR_call_description that is not empty
    const irDescription = analysis.IR_call_description?.trim();
    return !!(irDescription && irDescription.length > 0);
}

/**
 * Determine if a call is a non-IR call
 */
function isNonIrCall(payload: RetellAnalysisPayload): boolean {
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};

    // A call is considered non-IR if it has a non_IR_inquiry_reason or non_IR_call_description
    const nonIrReason = analysis.non_IR_inquiry_reason?.trim();
    const nonIrDescription = analysis.non_IR_call_description?.trim();

    return !!(
        (nonIrReason && nonIrReason.length > 0) ||
        (nonIrDescription && nonIrDescription.length > 0)
    );
}

/**
 * Build plain text transcript from payload
 */
function buildPlainTextTranscript(payload: RetellAnalysisPayload): string {
    let transcriptText = '';

    if (payload.transcript_object && Array.isArray(payload.transcript_object) && payload.transcript_object.length > 0) {
        transcriptText += '\n';
        transcriptText += '‚ïê'.repeat(70) + '\n';
        transcriptText += 'üìù COMPLETE CALL TRANSCRIPT\n';
        transcriptText += '‚ïê'.repeat(70) + '\n\n';

        for (const turn of payload.transcript_object) {
            const role = (turn.role || 'unknown').toLowerCase();
            const isAgent = role === 'agent';
            const speaker = isAgent ? 'ü§ñ AI Voice Agent' : 'üë§ Caller';
            const content = turn.content || '';

            transcriptText += `${speaker}:\n`;
            transcriptText += `${content}\n\n`;
        }

        transcriptText += '‚ïê'.repeat(70) + '\n';
    } else if (payload.transcript) {
        transcriptText += '\n';
        transcriptText += '‚ïê'.repeat(70) + '\n';
        transcriptText += 'üìù COMPLETE CALL TRANSCRIPT\n';
        transcriptText += '‚ïê'.repeat(70) + '\n\n';
        transcriptText += payload.transcript + '\n\n';
        transcriptText += '‚ïê'.repeat(70) + '\n';
    } else {
        transcriptText += '\nüìù COMPLETE CALL TRANSCRIPT\n';
        transcriptText += '(No transcript available)\n';
    }

    return transcriptText;
}

/**
 * Build plain text email body from payload
 */
function buildPlainTextEmail(payload: RetellAnalysisPayload): string {
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const summary = payload.summary || payload.call_analysis?.call_summary || 'No summary available';

    let text = '';

    // Header
    text += '‚ïî' + '‚ïê'.repeat(68) + '‚ïó\n';
    text += '‚ïë' + ' '.repeat(68) + '‚ïë\n';
    text += '‚ïë' + 'üö® NEW CYBERSECURITY INCIDENT REPORTED'.padStart(52).padEnd(68) + '‚ïë\n';
    text += '‚ïë' + ' '.repeat(68) + '‚ïë\n';
    text += '‚ïö' + '‚ïê'.repeat(68) + '‚ïù\n\n';

    // Call Recording & Resources
    if (payload.recording_url || payload.recording_multi_channel_url || payload.public_log_url) {
        text += '‚îÄ'.repeat(70) + '\n';
        text += 'üéß CALL RECORDING & RESOURCES\n';
        text += '‚îÄ'.repeat(70) + '\n\n';

        if (payload.recording_url) {
            text += 'üéµ Listen / Download Recording:\n';
            text += `   ${payload.recording_url}\n\n`;
        }

        if (payload.recording_multi_channel_url) {
            text += 'üéôÔ∏è Multi-channel Audio:\n';
            text += `   ${payload.recording_multi_channel_url}\n\n`;
        }

        if (payload.public_log_url) {
            text += 'üìã Public Log:\n';
            text += `   ${payload.public_log_url}\n\n`;
        }

        text += '‚îÄ'.repeat(70) + '\n\n';
    }

    // Incident Details
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'INCIDENT DETAILS\n';
    text += '‚îÄ'.repeat(70) + '\n\n';

    text += `Company Name:              ${analysis.company_name || 'N/A'}\n`;
    text += `Caller Name:               ${analysis.caller_name || 'N/A'}\n`;
    text += `Caller Email:              ${analysis.caller_email_address || 'N/A'}\n`;
    text += `Caller Phone:              ${analysis.caller_phone_number ? String(analysis.caller_phone_number) : 'N/A'}\n`;
    text += `Caller Location:           ${analysis.caller_location || 'Not provided'}\n`;
    text += `Current Customer:          ${analysis.current_customer === true || analysis.current_customer === 'true' ? 'Yes' : 'No'}\n`;
    text += `Primary Contact:           ${analysis.incident_is_customer_primary_contact === true || analysis.incident_is_customer_primary_contact === 'true' ? 'Yes' : 'No'}\n`;
    text += `Cyber Liability Insurance: ${analysis.incident_liability_insurance_status === 'yes' ? 'Yes' : 'No'}\n`;
    text += `Insurance Provider:        ${analysis.cybersecurity_insurance_provider_name || 'N/A'}\n\n`;

    // Incident Description
    text += '‚îÄ'.repeat(70) + '\n';
    text += '‚ö†Ô∏è  INCIDENT DESCRIPTION\n';
    text += '‚îÄ'.repeat(70) + '\n\n';
    text += `${analysis.IR_call_description || 'No description provided'}\n\n`;

    // Call Information
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'CALL INFORMATION\n';
    text += '‚îÄ'.repeat(70) + '\n\n';

    text += `Call ID:      ${payload.call_id}\n`;
    text += `Call Summary: ${summary}\n`;

    if (payload.call_cost?.combined_cost) {
        const costInDollars = (payload.call_cost.combined_cost / 100).toFixed(3);
        const duration = payload.call_cost.total_duration_seconds || 0;
        text += `Call Cost:    $${costInDollars} (${duration}s)\n`;
    }

    text += '\n';

    // Transcript
    text += buildPlainTextTranscript(payload);

    // Footer
    text += '\n\n';
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'This is an automated notification from the ProCircular Incident\n';
    text += 'Response System.\n\n';
    text += `Timestamp: ${new Date(payload.start_timestamp * 1000).toLocaleString()}\n`;
    text += '‚îÄ'.repeat(70) + '\n';

    return text;
}

/**
 * Build HTML email body from payload
 */
function buildHtmlEmailBody(payload: RetellAnalysisPayload): string {
    // Support both old format (analysis) and new format (call_analysis.custom_analysis_data)
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const summary = payload.summary || payload.call_analysis?.call_summary || 'No summary available';

    // Build a formatted transcript HTML (prefer structured transcript_object if available)
    let transcriptHtml = '';
    if (payload.transcript_object && Array.isArray(payload.transcript_object) && payload.transcript_object.length > 0) {
        transcriptHtml += '<div class="transcript-container">';
        transcriptHtml += '<h3 class="transcript-header">üìù Complete Call Transcript</h3>';
        transcriptHtml += '<div class="transcript">';
        for (const turn of payload.transcript_object) {
            const role = (turn.role || 'unknown').toLowerCase();
            const isAgent = role === 'agent';
            const speaker = isAgent ? 'ü§ñ AI Voice Agent' : 'üë§ Caller';
            const speakerClass = isAgent ? 'speaker-agent' : 'speaker-caller';
            // sanitize content minimally by replacing < with &lt; to avoid injection
            const content = (turn.content || '').replace(/</g, '&lt;');
            transcriptHtml += `\n<div class="turn ${speakerClass}"><div class="speaker">${speaker}:</div><div class="utterance">${content}</div></div>`;
        }
        transcriptHtml += '\n</div>';
        transcriptHtml += '</div>';
    } else if (payload.transcript) {
        // fallback: plain transcript text
        const safeTranscript = payload.transcript.replace(/</g, '&lt;').replace(/\n/g, '<br/>');
        transcriptHtml = `<div class="transcript-container"><h3 class="transcript-header">üìù Complete Call Transcript</h3><div class="transcript"><div class="utterance">${safeTranscript}</div></div></div>`;
    } else {
        transcriptHtml = '<div class="transcript-container"><h3 class="transcript-header">üìù Complete Call Transcript</h3><div class="transcript"><em>No transcript available</em></div></div>';
    }

    const htmlBody = `
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                .header { background-color: #d32f2f; color: white; padding: 20px; text-align: center; }
                .content { background-color: #f5f5f5; padding: 20px; margin-top: 20px; }
                .links { margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 6px; }
                .links-header { font-weight: bold; color: #1976d2; margin-bottom: 10px; font-size: 14px; }
                .link-button {
                    display: inline-block;
                    background: #1976d2;
                    color: #fff !important;
                    padding: 10px 16px;
                    border-radius: 4px;
                    text-decoration: none !important;
                    margin-right: 8px;
                    margin-bottom: 8px;
                    font-weight: 500;
                    border: none;
                }
                .link-button:hover { background: #1565c0; }
                .link-button:visited { color: #fff !important; }
                .transcript-container { margin-top: 25px; background: #ffffff; border: 2px solid #1976d2; border-radius: 6px; padding: 20px; }
                .transcript-header { margin: 0 0 15px 0; color: #1976d2; font-size: 18px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; }
                .transcript { background: #fafafa; border-radius: 4px; padding: 15px; max-height: 600px; overflow-y: auto; }
                .turn { margin-bottom: 15px; padding: 10px; border-radius: 4px; }
                .speaker-agent { background: #e8f5e9; border-left: 4px solid #4caf50; }
                .speaker-caller { background: #e3f2fd; border-left: 4px solid #2196f3; }
                .speaker { font-weight: bold; margin-bottom: 6px; font-size: 14px; }
                .speaker-agent .speaker { color: #2e7d32; }
                .speaker-caller .speaker { color: #1565c0; }
                .utterance { white-space: pre-wrap; line-height: 1.5; color: #333; }
                .field { margin-bottom: 15px; }
                .label { font-weight: bold; color: #555; }
                .value { margin-top: 5px; }
                .description-box { background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin-top: 20px; }
                .footer { margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 12px; color: #777; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üö® New Cybersecurity Incident Reported</h1>
                </div>
                <div class="content">
                    <div class="links">
                        <div class="links-header">üéß Call Recording & Resources</div>
                        <div style="margin-top: 10px;">
                            ${payload.recording_url ? `
                                <a class="link-button" href="${payload.recording_url}" target="_blank" rel="noopener noreferrer">üéµ Listen / Download Recording</a>
                            ` : ''}
                            ${payload.recording_multi_channel_url ? `
                                <a class="link-button" href="${payload.recording_multi_channel_url}" target="_blank" rel="noopener noreferrer">üéôÔ∏è Multi-channel Audio</a>
                            ` : ''}
                            ${payload.public_log_url ? `
                                <a class="link-button" href="${payload.public_log_url}" target="_blank" rel="noopener noreferrer">üìã Public Log</a>
                            ` : ''}
                        </div>
                        ${payload.recording_url || payload.recording_multi_channel_url || payload.public_log_url ? `
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #bbdefb; font-size: 12px; color: #666;">
                                <strong>Direct Links:</strong><br/>
                                ${payload.recording_url ? `üéµ Recording: <a href="${payload.recording_url}" target="_blank" style="color: #1976d2; word-break: break-all;">${payload.recording_url}</a><br/>` : ''}
                                ${payload.recording_multi_channel_url ? `üéôÔ∏è Multi-channel: <a href="${payload.recording_multi_channel_url}" target="_blank" style="color: #1976d2; word-break: break-all;">${payload.recording_multi_channel_url}</a><br/>` : ''}
                                ${payload.public_log_url ? `üìã Public Log: <a href="${payload.public_log_url}" target="_blank" style="color: #1976d2; word-break: break-all;">${payload.public_log_url}</a>` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div class="field">
                        <div class="label">Company Name:</div>
                        <div class="value">${analysis.company_name || 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Name:</div>
                        <div class="value">${analysis.caller_name || 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Email:</div>
                        <div class="value">${analysis.caller_email_address || 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Phone:</div>
                        <div class="value">${analysis.caller_phone_number ? String(analysis.caller_phone_number) : 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Location:</div>
                        <div class="value">${analysis.caller_location || 'Not provided'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Current Customer:</div>
                        <div class="value">${analysis.current_customer === true || analysis.current_customer === 'true' ? 'Yes' : 'No'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Primary Contact:</div>
                        <div class="value">${analysis.incident_is_customer_primary_contact === true || analysis.incident_is_customer_primary_contact === 'true' ? 'Yes' : 'No'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Cyber Liability Insurance:</div>
                        <div class="value">${analysis.incident_liability_insurance_status === 'yes' ? 'Yes' : 'No'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Insurance Provider:</div>
                        <div class="value">${analysis.cybersecurity_insurance_provider_name || 'N/A'}</div>
                    </div>
                    <div class="description-box">
                        <div class="label">Incident Description:</div>
                        <div class="value">${analysis.IR_call_description || 'No description provided'}</div>
                    </div>
                    <div class="field" style="margin-top: 20px;">
                        <div class="label">Call ID:</div>
                        <div class="value">${payload.call_id}</div>
                    </div>
                    <div class="field">
                        <div class="label">Call Summary:</div>
                        <div class="value">${summary}</div>
                    </div>
                    ${payload.call_cost?.combined_cost ? `
                    <div class="field">
                        <div class="label">Call Cost:</div>
                        <div class="value">$${(payload.call_cost.combined_cost / 100).toFixed(3)} (${payload.call_cost.total_duration_seconds || 0}s)</div>
                    </div>
                    ` : ''}

                    ${transcriptHtml}
                </div>
                <div class="footer">
                    <p>This is an automated notification from the ProCircular Incident Response System.</p>
                    <p>Timestamp: ${new Date(payload.start_timestamp * 1000).toLocaleString()}</p>
                </div>
            </div>
        </body>
        </html>
    `;

    return htmlBody;
}

/**
 * Send formatted email notification via Azure Communication Services
 */
async function sendEmailViaAzure(payload: RetellAnalysisPayload, config: ServiceConfig, context: InvocationContext): Promise<void> {
    context.log(`Sending email notification via Azure Communication Services...`);
    context.log(`  Provider: Azure`);
    context.log(`  Sender: ${config.azureEmail.senderEmail}`);
    context.log(`  Recipient: ${config.azureEmail.recipientEmail}`);

    // Initialize Azure Email Client
    const emailClient = new EmailClient(config.azureEmail.connectionString);

    // Support both old format (analysis) and new format (call_analysis.custom_analysis_data)
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const companyName = analysis.company_name || 'Unknown Company';

    // Build HTML and plain text email bodies
    const htmlBody = buildHtmlEmailBody(payload);
    const plainTextBody = buildPlainTextEmail(payload);

    // Build email message with Azure Communication Services format
    const message = {
        senderAddress: config.azureEmail.senderEmail,
        content: {
            subject: `[INCIDENT] ${companyName} - Cybersecurity Alert`,
            plainText: plainTextBody,
            html: htmlBody
        },
        recipients: {
            to: [
                {
                    address: config.azureEmail.recipientEmail,
                    displayName: "Incident Response Team"
                }
            ]
        },
        headers: {
            // Custom headers for better deliverability
            "X-Priority": "1",  // High priority
            "Importance": "high",  // Outlook-specific
            "X-MSMail-Priority": "High",  // Microsoft Mail priority
            "X-Mailer": "ProCircular IR System",  // Identify sender
            "X-Entity-Ref-ID": payload.call_id,  // Unique reference
            "List-Unsubscribe": "<mailto:unsubscribe@procircular.com>"  // Required for corporate filters
        },
        userEngagementTrackingDisabled: true  // Disable tracking for corporate compatibility
    };

    try {
        // Send email and get poller
        context.log('Initiating email send via Azure Communication Services...');
        const poller = await emailClient.beginSend(message);

        // Poll for completion (with timeout)
        context.log('Polling for email send status...');
        const result = await poller.pollUntilDone();

        // Check result status
        if (result.status === KnownEmailSendStatus.Succeeded) {
            context.log(`‚úÖ Email sent successfully via Azure Communication Services`);
            context.log(`   Message ID: ${result.id}`);
        } else {
            context.error(`‚ùå Email send failed via Azure Communication Services`);
            context.error(`   Status: ${result.status}`);
            context.error(`   Error: ${result.error?.message || 'Unknown error'}`);
            throw new Error(`Azure email send failed: ${result.status}`);
        }
    } catch (error) {
        context.error(`‚ùå Exception while sending email via Azure Communication Services:`);
        context.error(`   ${error instanceof Error ? error.message : String(error)}`);
        throw error;
    }
}

/**
 * Send formatted email notification via SendGrid
 */
async function sendEmailViaSendGrid(payload: RetellAnalysisPayload, config: ServiceConfig, context: InvocationContext): Promise<void> {
    context.log(`Sending email notification via SendGrid...`);
    context.log(`  Provider: SendGrid`);
    context.log(`  Sender: ${config.sendgrid.fromEmail}`);
    context.log(`  Recipient: ${config.sendgrid.toEmail}`);

    sgMail.setApiKey(config.sendgrid.apiKey);

    // Support both old format (analysis) and new format (call_analysis.custom_analysis_data)
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const companyName = analysis.company_name || 'Unknown Company';

    // Build HTML and plain text email bodies
    const htmlBody = buildHtmlEmailBody(payload);
    const plainTextBody = buildPlainTextEmail(payload);

    // Enhanced SendGrid message configuration for corporate email deliverability
    const msg = {
        to: config.sendgrid.toEmail,
        from: {
            email: config.sendgrid.fromEmail,
            name: 'ProCircular Incident Response'  // Friendly sender name
        },
        replyTo: config.sendgrid.fromEmail,  // Enable replies
        subject: `[INCIDENT] ${companyName} - Cybersecurity Alert`,  // Clear, professional subject
        text: plainTextBody,  // Plain text version (for Outlook and other clients that strip HTML)
        html: htmlBody,       // HTML version (for clients that support it)

        // Email categories for SendGrid analytics and filtering
        categories: ['incident-notification', 'cybersecurity', 'automated'],

        // Custom headers to improve deliverability and bypass spam filters
        headers: {
            'X-Priority': '1',  // High priority (1 = Highest, 3 = Normal, 5 = Lowest)
            'Importance': 'high',  // Outlook-specific importance flag
            'X-MSMail-Priority': 'High',  // Microsoft Mail priority
            'X-Mailer': 'ProCircular IR System',  // Identify the sending application
            'X-Entity-Ref-ID': payload.call_id,  // Unique reference for tracking
            'List-Unsubscribe': '<mailto:unsubscribe@procircular.com>',  // Required for corporate filters
            'Precedence': 'bulk',  // Indicate this is automated but important
        },

        // Tracking settings - DISABLE for corporate email compatibility
        trackingSettings: {
            clickTracking: {
                enable: false,  // Disabled - corporate filters often block link rewriting
                enableText: false
            },
            openTracking: {
                enable: false  // Disabled - corporate filters block tracking pixels
            },
            subscriptionTracking: {
                enable: false  // Disabled - we handle unsubscribe manually
            }
        },

        // Mail settings for better deliverability
        mailSettings: {
            bypassListManagement: {
                enable: false  // Respect SendGrid's suppression lists
            },
            footer: {
                enable: false  // No footer - keeps email clean
            },
            sandboxMode: {
                enable: false  // Ensure emails are actually sent
            }
        },

        // Custom arguments for webhook tracking (doesn't affect deliverability)
        customArgs: {
            call_id: payload.call_id,
            company: companyName,
            notification_type: 'incident_alert'
        }
    };

    await sgMail.send(msg);
    context.log('‚úÖ Email sent successfully via SendGrid (HTML + Plain Text)');
}

/**
 * Main email router function - routes to appropriate provider
 */
async function sendEmail(payload: RetellAnalysisPayload, config: ServiceConfig, context: InvocationContext): Promise<void> {
    context.log(`Email notification requested - Provider: ${config.emailProvider}`);

    if (config.emailProvider === 'azure') {
        await sendEmailViaAzure(payload, config, context);
    } else {
        await sendEmailViaSendGrid(payload, config, context);
    }
}

/**
 * Post notification to Microsoft Teams via Incoming Webhook using Adaptive Card
 */
async function sendTeamsMessage(payload: RetellAnalysisPayload, config: ServiceConfig, context: InvocationContext): Promise<void> {
    context.log('Sending Teams notification...');

    const { analysis } = payload;
    const companyName = analysis.company_name || 'Unknown Company';
    const callerName = analysis.caller_name || 'Unknown Caller';

    // Create an Adaptive Card for rich formatting
    const adaptiveCard = {
        type: "message",
        attachments: [
            {
                contentType: "application/vnd.microsoft.card.adaptive",
                content: {
                    type: "AdaptiveCard",
                    version: "1.4",
                    body: [
                        {
                            type: "Container",
                            style: "attention",
                            items: [
                                {
                                    type: "TextBlock",
                                    text: "üö® New Cybersecurity Incident Reported",
                                    weight: "bolder",
                                    size: "large",
                                    wrap: true,
                                    color: "attention"
                                }
                            ]
                        },
                        {
                            type: "FactSet",
                            facts: [
                                {
                                    title: "Company:",
                                    value: companyName
                                },
                                {
                                    title: "Caller:",
                                    value: callerName
                                },
                                {
                                    title: "Phone:",
                                    value: analysis.caller_phone_number || 'N/A'
                                },
                                {
                                    title: "Email:",
                                    value: analysis.caller_email_address || 'N/A'
                                },
                                {
                                    title: "Current Customer:",
                                    value: analysis.current_customer === 'true' ? 'Yes' : 'No'
                                },
                                {
                                    title: "Cyber Insurance:",
                                    value: analysis.incident_liability_insurance_status === 'yes' ? 'Yes' : 'No'
                                },
                                {
                                    title: "Insurance Provider:",
                                    value: analysis.cybersecurity_insurance_provider_name || 'N/A'
                                }
                            ]
                        },
                        {
                            type: "Container",
                            style: "warning",
                            items: [
                                {
                                    type: "TextBlock",
                                    text: "Incident Description",
                                    weight: "bolder",
                                    wrap: true
                                },
                                {
                                    type: "TextBlock",
                                    text: analysis.IR_call_description || 'No description provided',
                                    wrap: true,
                                    spacing: "small"
                                }
                            ]
                        },
                        {
                            type: "TextBlock",
                            text: `Call ID: ${payload.call_id}`,
                            size: "small",
                            isSubtle: true,
                            wrap: true,
                            spacing: "medium"
                        },
                        {
                            type: "TextBlock",
                            text: `Received: ${new Date(payload.start_timestamp * 1000).toLocaleString()}`,
                            size: "small",
                            isSubtle: true,
                            wrap: true
                        }
                    ]
                }
            }
        ]
    };

    const response = await fetch(config.teams.webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(adaptiveCard)
    });

    if (!response.ok) {
        throw new Error(`Teams webhook failed: ${response.status} ${response.statusText}`);
    }

    context.log('Teams notification sent successfully');
}

/**
 * Send SMS alert via Twilio
 */
async function sendSms(payload: RetellAnalysisPayload, config: ServiceConfig, context: InvocationContext): Promise<void> {
    context.log('Sending SMS notification...');

    const client = twilio(config.twilio.accountSid, config.twilio.authToken);
    const { analysis } = payload;

    const callerName = analysis.caller_name || 'Unknown Caller';
    const companyName = analysis.company_name || 'Unknown Company';

    const message = `New ProCircular IR Alert: Incident reported by ${callerName} from ${companyName}. Check email/Teams for details.`;

    await client.messages.create({
        body: message,
        from: config.twilio.fromNumber,
        to: config.twilio.toNumber
    });

    context.log('SMS sent successfully');
}

/**
 * Helper function to safely convert values to strings with defaults
 */
function getString(value: any, defaultValue: string = 'Not provided'): string {
    if (value === null || value === undefined || value === '') return defaultValue;
    return String(value);
}

/**
 * Helper function to convert boolean/string values to Yes/No
 */
function getYesNo(value: any): string {
    if (value === true || value === 'true' || value === 'yes') return 'Yes';
    if (value === false || value === 'false' || value === 'no') return 'No';
    return 'Unknown';
}

/**
 * Create Jira ticket via REST API (replaces webhook integration)
 */
async function createJiraTicketViaApi(
    payload: RetellAnalysisPayload,
    config: ServiceConfig,
    context: InvocationContext
): Promise<void> {
    context.log('üì§ Creating Jira ticket via REST API...');

    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const callAnalysis = payload.call_analysis || {};
    const summary = payload.summary || callAnalysis.call_summary || 'No summary available';

    // Extract call metadata
    const callDurationSeconds = payload.duration_ms ? Math.round(payload.duration_ms / 1000) :
                                (payload.call_cost?.total_duration_seconds || 0);
    const disconnectionReason = payload.disconnection_reason || 'Unknown';
    const userSentiment = callAnalysis.user_sentiment || 'Unknown';
    const callSuccessful = callAnalysis.call_successful !== undefined ?
                          (callAnalysis.call_successful ? 'Yes' : 'No') : 'Unknown';

    // Create Basic Authentication header
    const authToken = Buffer.from(`${config.jira.userEmail}:${config.jira.apiToken}`).toString('base64');
    const endpoint = `${config.jira.apiUrl}/rest/api/3/issue`;

    // Build Jira API payload with proper field structure
    const jiraPayload = {
        fields: {
            project: {
                key: config.jira.projectKey
            },
            issuetype: {
                name: "[System] Incident"
            },
            summary: `üö® IR Call: ${getString(analysis.company_name, 'Unknown Company')} - ${getString(analysis.caller_name, 'Unknown Caller')}`,

            // Set Request Type to match JIRA Service Management format
            // Note: customfield_10010 is a special JSM field that expects just the string ID
            customfield_10010: "250",  // Request Type ID for "DEV - Report a Cybersecurity Incident"

            // Map to custom fields discovered in Jira
            customfield_10106: getString(analysis.company_name),  // Company
            customfield_10109: getString(analysis.caller_name),  // FirstLastName
            customfield_10110: getString(analysis.caller_email_address),  // Email Address
            customfield_10111: getString(analysis.caller_phone_number),  // Phone Number
            customfield_10113: getString(analysis.caller_location),  // Location (City/State)
            customfield_10107: { value: getYesNo(analysis.incident_liability_insurance_status) },  // CyberInsurance (Radio Buttons)
            customfield_10108: { value: getYesNo(analysis.current_customer) },  // ActiveIRContract (Radio Buttons)

            // Build rich description using Atlassian Document Format (ADF)
            description: {
                type: "doc",
                version: 1,
                content: [
                    {
                        type: "panel",
                        attrs: { panelType: "warning" },
                        content: [
                            {
                                type: "paragraph",
                                content: [
                                    { type: "text", text: "üö® INCIDENT ALERT", marks: [{ type: "strong" }] }
                                ]
                            }
                        ]
                    },
                    {
                        type: "panel",
                        attrs: { panelType: "info" },
                        content: [
                            {
                                type: "paragraph",
                                content: [
                                    { type: "text", text: "AI-Generated Summary: ", marks: [{ type: "strong" }] },
                                    { type: "text", text: summary }
                                ]
                            }
                        ]
                    },
                    {
                        type: "heading",
                        attrs: { level: 3 },
                        content: [{ type: "text", text: "Caller Information" }]
                    },
                    {
                        type: "paragraph",
                        content: [
                            { type: "text", text: "Company: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(analysis.company_name) },
                            { type: "hardBreak" },
                            { type: "text", text: "Caller: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(analysis.caller_name) },
                            { type: "hardBreak" },
                            { type: "text", text: "Email: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(analysis.caller_email_address) },
                            { type: "hardBreak" },
                            { type: "text", text: "Phone: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(analysis.caller_phone_number) },
                            { type: "hardBreak" },
                            { type: "text", text: "Location: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(analysis.caller_location) }
                        ]
                    },
                    {
                        type: "heading",
                        attrs: { level: 3 },
                        content: [{ type: "text", text: "Incident Details" }]
                    },
                    {
                        type: "paragraph",
                        content: [
                            { type: "text", text: "Current Customer: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getYesNo(analysis.current_customer) },
                            { type: "hardBreak" },
                            { type: "text", text: "Primary Contact: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getYesNo(analysis.incident_is_customer_primary_contact) },
                            { type: "hardBreak" },
                            { type: "text", text: "Cyber Insurance: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getYesNo(analysis.incident_liability_insurance_status) },
                            { type: "hardBreak" },
                            { type: "text", text: "Insurance Provider: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(analysis.cybersecurity_insurance_provider_name) },
                            { type: "hardBreak" },
                            { type: "text", text: "Security Incident: ", marks: [{ type: "strong" }] },
                            { type: "text", text: analysis.is_security_incident === true ? 'Yes' : 'No' }
                        ]
                    },
                    {
                        type: "heading",
                        attrs: { level: 3 },
                        content: [{ type: "text", text: "Incident Description" }]
                    },
                    {
                        type: "paragraph",
                        content: [
                            { type: "text", text: getString(analysis.IR_call_description, 'No description provided') }
                        ]
                    },
                    {
                        type: "heading",
                        attrs: { level: 3 },
                        content: [{ type: "text", text: "Call Metadata" }]
                    },
                    {
                        type: "paragraph",
                        content: [
                            { type: "text", text: "Call Duration: ", marks: [{ type: "strong" }] },
                            { type: "text", text: `${callDurationSeconds} seconds (${Math.floor(callDurationSeconds / 60)}m ${callDurationSeconds % 60}s)` },
                            { type: "hardBreak" },
                            { type: "text", text: "Disconnection Reason: ", marks: [{ type: "strong" }] },
                            { type: "text", text: disconnectionReason.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) },
                            { type: "hardBreak" },
                            { type: "text", text: "User Sentiment: ", marks: [{ type: "strong" }] },
                            { type: "text", text: userSentiment },
                            { type: "hardBreak" },
                            { type: "text", text: "Call Successful: ", marks: [{ type: "strong" }] },
                            { type: "text", text: callSuccessful },
                            { type: "hardBreak" },
                            { type: "text", text: "Agent Name: ", marks: [{ type: "strong" }] },
                            { type: "text", text: getString(payload.agent_name, 'Not specified') }
                        ]
                    },
                    {
                        type: "heading",
                        attrs: { level: 3 },
                        content: [{ type: "text", text: "Call Recording & Resources" }]
                    },
                    {
                        type: "bulletList",
                        content: [
                            {
                                type: "listItem",
                                content: [{
                                    type: "paragraph",
                                    content: [
                                        { type: "text", text: "Listen to Recording", marks: [{ type: "link", attrs: { href: payload.recording_url || "#" } }] }
                                    ]
                                }]
                            },
                            {
                                type: "listItem",
                                content: [{
                                    type: "paragraph",
                                    content: [
                                        { type: "text", text: "Multi-channel Audio", marks: [{ type: "link", attrs: { href: payload.recording_multi_channel_url || "#" } }] }
                                    ]
                                }]
                            },
                            {
                                type: "listItem",
                                content: [{
                                    type: "paragraph",
                                    content: [
                                        { type: "text", text: "Public Log", marks: [{ type: "link", attrs: { href: payload.public_log_url || "#" } }] }
                                    ]
                                }]
                            }
                        ]
                    },
                    {
                        type: "heading",
                        attrs: { level: 3 },
                        content: [{ type: "text", text: "Full Transcript" }]
                    },
                    {
                        type: "codeBlock",
                        attrs: { language: "text" },
                        content: [{
                            type: "text",
                            text: payload.transcript || 'No transcript available'
                        }]
                    },
                    {
                        type: "rule"
                    },
                    {
                        type: "paragraph",
                        content: [
                            { type: "text", text: "This ticket was created automatically by the ProCircular IR Relay system.", marks: [{ type: "em" }] }
                        ]
                    }
                ]
            }
        }
    };

    context.log(`üì§ Sending Jira API request to: ${endpoint}`);
    context.log(`üìã Ticket summary: ${jiraPayload.fields.summary}`);

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${authToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(jiraPayload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            context.error(`‚ùå Jira API request failed with status ${response.status}: ${errorText}`);
            throw new Error(`Jira API request failed: ${response.status} - ${errorText}`);
        }

        const responseData: any = await response.json();
        const ticketKey = responseData.key;
        const ticketUrl = `${config.jira.apiUrl}/browse/${ticketKey}`;

        context.log(`‚úÖ Jira ticket created successfully: ${ticketKey}`);
        context.log(`üîó View ticket: ${ticketUrl}`);

    } catch (error) {
        context.error(`‚ùå Error creating Jira ticket: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
    }
}

/**
 * Build HTML email body for non-IR calls
 */
function buildNonIrHtmlEmailBody(payload: RetellAnalysisPayload): string {
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const summary = payload.summary || payload.call_analysis?.call_summary || 'No summary available';

    // Build a formatted transcript HTML
    let transcriptHtml = '';
    if (payload.transcript_object && Array.isArray(payload.transcript_object) && payload.transcript_object.length > 0) {
        transcriptHtml += '<div class="transcript-container">';
        transcriptHtml += '<h3 class="transcript-header">üìù Complete Call Transcript</h3>';
        transcriptHtml += '<div class="transcript">';
        for (const turn of payload.transcript_object) {
            const role = (turn.role || 'unknown').toLowerCase();
            const isAgent = role === 'agent';
            const speaker = isAgent ? 'ü§ñ AI Voice Agent' : 'üë§ Caller';
            const speakerClass = isAgent ? 'speaker-agent' : 'speaker-caller';
            const content = (turn.content || '').replace(/</g, '&lt;');
            transcriptHtml += `\n<div class="turn ${speakerClass}"><div class="speaker">${speaker}:</div><div class="utterance">${content}</div></div>`;
        }
        transcriptHtml += '\n</div>';
        transcriptHtml += '</div>';
    } else if (payload.transcript) {
        const safeTranscript = payload.transcript.replace(/</g, '&lt;').replace(/\n/g, '<br/>');
        transcriptHtml = `<div class="transcript-container"><h3 class="transcript-header">üìù Complete Call Transcript</h3><div class="transcript"><div class="utterance">${safeTranscript}</div></div></div>`;
    } else {
        transcriptHtml = '<div class="transcript-container"><h3 class="transcript-header">üìù Complete Call Transcript</h3><div class="transcript"><em>No transcript available</em></div></div>';
    }

    const htmlBody = `
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                .header { background-color: #1976d2; color: white; padding: 20px; text-align: center; }
                .content { background-color: #f5f5f5; padding: 20px; margin-top: 20px; }
                .links { margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 6px; }
                .links-header { font-weight: bold; color: #1976d2; margin-bottom: 10px; font-size: 14px; }
                .link-button {
                    display: inline-block;
                    background: #1976d2;
                    color: #fff !important;
                    padding: 10px 16px;
                    border-radius: 4px;
                    text-decoration: none !important;
                    margin-right: 8px;
                    margin-bottom: 8px;
                    font-weight: 500;
                    border: none;
                }
                .link-button:hover { background: #1565c0; }
                .link-button:visited { color: #fff !important; }
                .transcript-container { margin-top: 25px; background: #ffffff; border: 2px solid #1976d2; border-radius: 6px; padding: 20px; }
                .transcript-header { margin: 0 0 15px 0; color: #1976d2; font-size: 18px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; }
                .transcript { background: #fafafa; border-radius: 4px; padding: 15px; max-height: 600px; overflow-y: auto; }
                .turn { margin-bottom: 15px; padding: 10px; border-radius: 4px; }
                .speaker-agent { background: #e8f5e9; border-left: 4px solid #4caf50; }
                .speaker-caller { background: #e3f2fd; border-left: 4px solid #2196f3; }
                .speaker { font-weight: bold; margin-bottom: 6px; font-size: 14px; }
                .speaker-agent .speaker { color: #2e7d32; }
                .speaker-caller .speaker { color: #1565c0; }
                .utterance { white-space: pre-wrap; line-height: 1.5; color: #333; }
                .field { margin-bottom: 15px; }
                .label { font-weight: bold; color: #555; }
                .value { margin-top: 5px; }
                .summary-box { background-color: #e3f2fd; border-left: 4px solid #1976d2; padding: 15px; margin-top: 20px; }
                .footer { margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 12px; color: #777; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üìû General Inquiry Call Summary</h1>
                </div>
                <div class="content">
                    ${payload.recording_url || payload.recording_multi_channel_url || payload.public_log_url ? `
                    <div class="links">
                        <div class="links-header">üéß Call Recording & Resources</div>
                        <div style="margin-top: 10px;">
                            ${payload.recording_url ? `
                                <a class="link-button" href="${payload.recording_url}" target="_blank" rel="noopener noreferrer">üéµ Listen / Download Recording</a>
                            ` : ''}
                            ${payload.recording_multi_channel_url ? `
                                <a class="link-button" href="${payload.recording_multi_channel_url}" target="_blank" rel="noopener noreferrer">üéôÔ∏è Multi-channel Audio</a>
                            ` : ''}
                            ${payload.public_log_url ? `
                                <a class="link-button" href="${payload.public_log_url}" target="_blank" rel="noopener noreferrer">üìã Public Log</a>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}
                    <div class="field">
                        <div class="label">Company Name:</div>
                        <div class="value">${analysis.company_name || 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Name:</div>
                        <div class="value">${analysis.caller_name || 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Email:</div>
                        <div class="value">${analysis.caller_email_address || 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Phone:</div>
                        <div class="value">${analysis.caller_phone_number ? String(analysis.caller_phone_number) : 'N/A'}</div>
                    </div>
                    <div class="field">
                        <div class="label">Caller Location:</div>
                        <div class="value">${analysis.caller_location || 'Not provided'}</div>
                    </div>
                    ${analysis.non_IR_inquiry_reason ? `
                    <div class="field">
                        <div class="label">Inquiry Type:</div>
                        <div class="value">${analysis.non_IR_inquiry_reason}</div>
                    </div>
                    ` : ''}
                    ${analysis.non_IR_call_description ? `
                    <div class="summary-box">
                        <strong>Description:</strong><br/>
                        ${analysis.non_IR_call_description.replace(/\n/g, '<br/>')}
                    </div>
                    ` : ''}
                    <div class="summary-box">
                        <strong>Call Summary:</strong><br/>
                        ${summary.replace(/\n/g, '<br/>')}
                    </div>
                    <div class="field">
                        <div class="label">Call ID:</div>
                        <div class="value">${payload.call_id}</div>
                    </div>
                    ${transcriptHtml}
                    <div class="footer">
                        This is an automated notification from the ProCircular Incident Response System.<br/>
                        Timestamp: ${new Date(payload.start_timestamp * 1000).toLocaleString()}
                    </div>
                </div>
            </div>
        </body>
        </html>
    `;

    return htmlBody;
}

/**
 * Build plain text email body for non-IR calls
 */
function buildNonIrPlainTextEmail(payload: RetellAnalysisPayload): string {
    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const summary = payload.summary || payload.call_analysis?.call_summary || 'No summary available';

    let text = '';

    // Header
    text += '‚ïî' + '‚ïê'.repeat(68) + '‚ïó\n';
    text += '‚ïë' + ' '.repeat(68) + '‚ïë\n';
    text += '‚ïë' + 'üìû GENERAL INQUIRY CALL SUMMARY'.padStart(50).padEnd(68) + '‚ïë\n';
    text += '‚ïë' + ' '.repeat(68) + '‚ïë\n';
    text += '‚ïö' + '‚ïê'.repeat(68) + '‚ïù\n\n';

    // Call Recording & Resources
    if (payload.recording_url || payload.recording_multi_channel_url || payload.public_log_url) {
        text += '‚îÄ'.repeat(70) + '\n';
        text += 'üéß CALL RECORDING & RESOURCES\n';
        text += '‚îÄ'.repeat(70) + '\n\n';

        if (payload.recording_url) {
            text += 'üéµ Listen / Download Recording:\n';
            text += `   ${payload.recording_url}\n\n`;
        }

        if (payload.recording_multi_channel_url) {
            text += 'üéôÔ∏è Multi-channel Audio:\n';
            text += `   ${payload.recording_multi_channel_url}\n\n`;
        }

        if (payload.public_log_url) {
            text += 'üìã Public Log:\n';
            text += `   ${payload.public_log_url}\n\n`;
        }

        text += '‚îÄ'.repeat(70) + '\n\n';
    }

    // Caller Details
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'CALLER INFORMATION\n';
    text += '‚îÄ'.repeat(70) + '\n\n';

    text += `Company Name:     ${analysis.company_name || 'N/A'}\n`;
    text += `Caller Name:      ${analysis.caller_name || 'N/A'}\n`;
    text += `Caller Email:     ${analysis.caller_email_address || 'N/A'}\n`;
    text += `Caller Phone:     ${analysis.caller_phone_number ? String(analysis.caller_phone_number) : 'N/A'}\n`;
    text += `Caller Location:  ${analysis.caller_location || 'Not provided'}\n\n`;

    // Inquiry Details
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'INQUIRY DETAILS\n';
    text += '‚îÄ'.repeat(70) + '\n\n';

    if (analysis.non_IR_inquiry_reason) {
        text += `Inquiry Type: ${analysis.non_IR_inquiry_reason}\n\n`;
    }

    if (analysis.non_IR_call_description) {
        text += `Description:\n${analysis.non_IR_call_description}\n\n`;
    }

    // Call Summary
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'CALL SUMMARY\n';
    text += '‚îÄ'.repeat(70) + '\n\n';
    text += `${summary}\n\n`;

    // Call Information
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'CALL INFORMATION\n';
    text += '‚îÄ'.repeat(70) + '\n\n';

    text += `Call ID: ${payload.call_id}\n`;

    if (payload.call_cost?.combined_cost) {
        const costInDollars = (payload.call_cost.combined_cost / 100).toFixed(3);
        const duration = payload.call_cost.total_duration_seconds || 0;
        text += `Call Cost: $${costInDollars} (${duration}s)\n`;
    }

    text += '\n';

    // Transcript
    text += buildPlainTextTranscript(payload);

    // Footer
    text += '\n\n';
    text += '‚îÄ'.repeat(70) + '\n';
    text += 'This is an automated notification from the ProCircular\n';
    text += 'Incident Response System.\n\n';
    text += `Timestamp: ${new Date(payload.start_timestamp * 1000).toLocaleString()}\n`;
    text += '‚îÄ'.repeat(70) + '\n';

    return text;
}

/**
 * Send non-IR email summary via SendGrid or Azure
 */
async function sendNonIrEmail(payload: RetellAnalysisPayload, config: ServiceConfig, context: InvocationContext): Promise<void> {
    context.log('Sending non-IR email summary...');
    context.log(`  Provider: ${config.emailProvider}`);
    context.log(`  Recipient: ${config.nonIrEmail.recipientEmail}`);

    const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
    const companyName = analysis.company_name || 'Unknown Company';

    // Build HTML and plain text email bodies
    const htmlBody = buildNonIrHtmlEmailBody(payload);
    const plainTextBody = buildNonIrPlainTextEmail(payload);

    if (config.emailProvider === 'azure') {
        // Send via Azure Communication Services
        const emailClient = new EmailClient(config.azureEmail.connectionString);

        const message = {
            senderAddress: config.azureEmail.senderEmail,
            content: {
                subject: `[NON-IR] General Inquiry - ${companyName}`,
                plainText: plainTextBody,
                html: htmlBody
            },
            recipients: {
                to: [
                    {
                        address: config.nonIrEmail.recipientEmail,
                        displayName: "ProCircular Team"
                    }
                ]
            },
            userEngagementTrackingDisabled: true
        };

        const poller = await emailClient.beginSend(message);
        const result = await poller.pollUntilDone();

        if (result.status === KnownEmailSendStatus.Succeeded) {
            context.log(`‚úÖ Non-IR email sent successfully via Azure Communication Services`);
        } else {
            throw new Error(`Azure email send failed: ${result.status}`);
        }
    } else {
        // Send via SendGrid
        sgMail.setApiKey(config.sendgrid.apiKey);

        const msg = {
            to: config.nonIrEmail.recipientEmail,
            from: {
                email: config.sendgrid.fromEmail,
                name: 'ProCircular Incident Response'
            },
            replyTo: config.sendgrid.fromEmail,
            subject: `[NON-IR] General Inquiry - ${companyName}`,
            text: plainTextBody,
            html: htmlBody,
            categories: ['non-ir-inquiry', 'general-question', 'automated'],
            trackingSettings: {
                clickTracking: { enable: false, enableText: false },
                openTracking: { enable: false },
                subscriptionTracking: { enable: false }
            },
            customArgs: {
                call_id: payload.call_id,
                company: companyName,
                notification_type: 'non_ir_summary'
            }
        };

        await sgMail.send(msg);
        context.log('‚úÖ Non-IR email sent successfully via SendGrid');
    }
}

/**
 * Main Azure Function handler for Retell AI webhook
 */
export async function RetellWebhookProcessor(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    context.log('Retell AI webhook received');

    try {
        // --- START: RETELL SIGNATURE VERIFICATION ---
        const retellApiKey = process.env.RETELL_API_KEY;
        const signature = request.headers.get("x-retell-signature");

        let webhookPayload: RetellWebhookPayload;

        if (!retellApiKey) {
            context.error("CRITICAL: RETELL_API_KEY is not set. Rejecting request for security.");
            return {
                status: 500,
                jsonBody: { success: false, error: "Server configuration error." }
            };
        }

        if (!signature) {
            context.warn("Missing 'x-retell-signature' header. RetellAI may not be configured to send it. Rejecting request.");
            return {
                status: 400,
                jsonBody: { success: false, error: "Missing x-retell-signature header." }
            };
        } else {
            // Must read the body as raw text for verification
            const rawBody = await request.text();

            // Log for debugging (first 100 chars of body and signature)
            context.log(`DEBUG: Body length: ${rawBody.length}, Body preview: ${rawBody.substring(0, 100)}`);
            context.log(`DEBUG: Signature: ${signature.substring(0, 20)}...`);
            context.log(`DEBUG: API Key (first 10): ${retellApiKey.substring(0, 10)}...`);

            if (!Retell.verify(rawBody, retellApiKey, signature)) {
                context.error("‚ùå Invalid Retell signature. Rejecting request.");
                context.error(`DEBUG: Verification failed with key starting: ${retellApiKey.substring(0, 15)}`);
                return {
                    status: 401,
                    jsonBody: { success: false, error: "Invalid signature." }
                };
            }
            context.log("‚úÖ Retell signature verified successfully.");

            // IMPORTANT: Parse the JSON *after* verifying the raw string
            webhookPayload = JSON.parse(rawBody);
        }
        // --- END: RETELL SIGNATURE VERIFICATION ---

        // --- START: EVENT TYPE FILTERING ---
        // RetellAI sends 3 event types: call_started, call_ended, call_analyzed
        // We ONLY process call_analyzed events (which contain the analysis data)
        const eventType = webhookPayload.event;

        if (eventType !== 'call_analyzed') {
            context.log(`Ignoring ${eventType} event for call ID: ${webhookPayload.call?.call_id || 'unknown'}`);
            return {
                status: 200,
                jsonBody: {
                    success: true,
                    message: `Event type ${eventType} acknowledged but not processed`
                }
            };
        }
        // --- END: EVENT TYPE FILTERING ---

        // Extract the actual call object from the webhook envelope
        const payload: RetellAnalysisPayload = webhookPayload.call;

        context.log(`Processing call_analyzed event for call ID: ${payload.call_id}`);

        // --- START: DETAILED PAYLOAD LOGGING ---
        // Log the complete webhook payload to see exactly what RetellAI sends
        context.log('=== COMPLETE WEBHOOK PAYLOAD ===');
        context.log(JSON.stringify(webhookPayload, null, 2));
        context.log('=== END WEBHOOK PAYLOAD ===');

        // Log specific data extraction paths
        context.log('Data extraction check:');
        context.log(`  - payload.analysis exists: ${!!payload.analysis}`);
        context.log(`  - payload.call_analysis exists: ${!!payload.call_analysis}`);
        context.log(`  - payload.call_analysis?.custom_analysis_data exists: ${!!payload.call_analysis?.custom_analysis_data}`);

        if (payload.call_analysis?.custom_analysis_data) {
            context.log('  - custom_analysis_data contents:');
            context.log(JSON.stringify(payload.call_analysis.custom_analysis_data, null, 2));
        }
        // --- END: DETAILED PAYLOAD LOGGING ---

        const analysis = payload.analysis || payload.call_analysis?.custom_analysis_data || {};
        context.log(`Company: ${analysis.company_name || 'Unknown'}, Caller: ${analysis.caller_name || 'Unknown'}`);
        context.log(`IR Description: ${analysis.IR_call_description || 'Not provided'}`);
        context.log(`Non-IR Description: ${analysis.non_IR_call_description || 'Not provided'}`);

        // Load configuration from environment variables
        const config = loadConfiguration();

        // Determine call type
        const isIr = isIrCall(payload);
        const isNonIr = isNonIrCall(payload);

        context.log(`Call type determination:`);
        context.log(`  - IR Call: ${isIr ? 'YES' : 'NO'}`);
        context.log(`  - Non-IR Call: ${isNonIr ? 'YES' : 'NO'}`);

        // Log which notification channels are enabled
        context.log('Notification channels status:');
        context.log(`  - Email: ${config.featureFlags.enableEmail ? 'ENABLED' : 'DISABLED'}`);
        context.log(`  - Teams: ${config.featureFlags.enableTeams ? 'ENABLED' : 'DISABLED'}`);
        context.log(`  - SMS: ${config.featureFlags.enableSms ? 'ENABLED' : 'DISABLED'}`);
        context.log(`  - Jira: ${config.featureFlags.enableJira ? 'ENABLED' : 'DISABLED'}`);

        // Build array of notification tasks based on call type
        const notificationTasks: Promise<void>[] = [];
        let callType = 'unknown';
        let results: PromiseSettledResult<void>[] = [];

        if (isIr) {
            // IR CALL WORKFLOW
            callType = 'IR';
            context.log('üö® Processing as IR (Incident Response) call');

            // Add Jira ticket creation for IR calls
            if (config.featureFlags.enableJira) {
                context.log('Adding Jira ticket creation to queue...');
                notificationTasks.push(createJiraTicketViaApi(payload, config, context));
            }

            // Add IR alert email
            if (config.featureFlags.enableEmail) {
                context.log('Adding IR alert email to queue...');
                notificationTasks.push(sendEmail(payload, config, context));
            }

            // Add Teams notification
            if (config.featureFlags.enableTeams) {
                context.log('Adding Teams notification to queue...');
                notificationTasks.push(sendTeamsMessage(payload, config, context));
            }

            // Add SMS alert
            if (config.featureFlags.enableSms) {
                context.log('Adding SMS notification to queue...');
                notificationTasks.push(sendSms(payload, config, context));
            }

        } else if (isNonIr) {
            // NON-IR CALL WORKFLOW
            callType = 'NON-IR';
            context.log('üìû Processing as Non-IR (General Inquiry) call');

            // Only send non-IR email summary (no Jira, Teams, or SMS)
            context.log('Adding non-IR email summary to queue...');
            notificationTasks.push(sendNonIrEmail(payload, config, context));

        } else {
            // UNCLASSIFIED CALL - Default to IR workflow for safety
            callType = 'UNCLASSIFIED (defaulting to IR)';
            context.log('‚ö†Ô∏è  WARNING: Call type could not be determined. Defaulting to IR workflow for safety.');

            // Default to IR workflow
            if (config.featureFlags.enableJira) {
                context.log('Adding Jira ticket creation to queue (default)...');
                notificationTasks.push(createJiraTicketViaApi(payload, config, context));
            }

            if (config.featureFlags.enableEmail) {
                context.log('Adding IR alert email to queue (default)...');
                notificationTasks.push(sendEmail(payload, config, context));
            }

            if (config.featureFlags.enableTeams) {
                context.log('Adding Teams notification to queue (default)...');
                notificationTasks.push(sendTeamsMessage(payload, config, context));
            }

            if (config.featureFlags.enableSms) {
                context.log('Adding SMS notification to queue (default)...');
                notificationTasks.push(sendSms(payload, config, context));
            }
        }

        // Execute notification tasks in parallel with resilient error handling
        if (notificationTasks.length > 0) {
            context.log(`Triggering ${notificationTasks.length} notification(s) in parallel...`);

            // Use Promise.allSettled to allow partial success
            results = await Promise.allSettled(notificationTasks);

            // Count successes and failures
            const successes = results.filter(r => r.status === 'fulfilled');
            const failures = results.filter(r => r.status === 'rejected');

            // Log results
            context.log(`‚úÖ ${successes.length}/${notificationTasks.length} notification(s) sent successfully`);

            if (failures.length > 0) {
                context.warn(`‚ö†Ô∏è  ${failures.length} notification(s) failed:`);
                failures.forEach((failure, index) => {
                    if (failure.status === 'rejected') {
                        context.error(`  - Notification ${index + 1}: ${failure.reason}`);
                    }
                });
            }
        } else {
            context.log('WARNING: No notification channels are enabled. No notifications will be sent.');
        }

        // Build notification status summary
        const notificationStatus = notificationTasks.length > 0 ? {
            total: notificationTasks.length,
            successful: results ? results.filter(r => r.status === 'fulfilled').length : 0,
            failed: results ? results.filter(r => r.status === 'rejected').length : 0
        } : { total: 0, successful: 0, failed: 0 };

        return {
            status: 200,
            jsonBody: {
                success: true,
                message: 'Webhook processed successfully',
                call_id: payload.call_id,
                call_type: callType,
                notifications_attempted: {
                    jira: isIr && config.featureFlags.enableJira,
                    email: (isIr && config.featureFlags.enableEmail) || isNonIr,
                    teams: isIr && config.featureFlags.enableTeams,
                    sms: isIr && config.featureFlags.enableSms
                },
                notification_results: notificationStatus
            }
        };

    } catch (error) {
        context.error('Error processing webhook:', error);

        return {
            status: 500,
            jsonBody: {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred'
            }
        };
    }
}

// Register the function with Azure Functions runtime
// Note: Using 'anonymous' auth level because RetellAI uses signature verification for security
app.http('RetellWebhookProcessor', {
    methods: ['POST'],
    authLevel: 'anonymous',  // RetellAI webhooks use signature verification, not function keys
    handler: RetellWebhookProcessor
});
